# 【基础】HTTP、TCP/IP 协议的原理及应用

## 前言
HTTP 非常重要和基础

## 经典网络五层模型
![经典网络五层模型](https://github.com/CRONWMMM/IT-output/blob/master/images/%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B.png)

在每台计算机设备上，都有这么一套系统链路的关系，来保证网络传输的正常进行，因为统一集成了这么一套经典模型，所以自己使用的计算机也是可以作为一台服务器来提供网络服务的。

### 应用层：
应用层包含了我们所说的 `HTTP` 协议，为各个应用软件提供了很多服务，常见的应用层服务有：`HTTP` 服务 、`FTP` 服务 、`Email` 服务`HTTP` 等。应用层屏蔽了底层模型的相关细节，作为应用支持，只提供给使用者一些必要的使用方式。

### 传输层
传输层作为为应用层的基础，定义了“端到端（end to end）”之间数据间的传输方式，比如：两台设备如何建立连接？设备之间需要以何种规范进行数据传输？需要以什么方式进行数据的分片、重组、拼接？这些都是传输层为我们定义好的。

### 网络层
网络层为数据在结点之间传输创建逻辑链路，当我们在浏览器敲下域名，浏览器在网络里如何通过这个域名，找到对应的 `IP` 映射，这个查询的逻辑关系和链路，是网络层规范和定义的。

### 数据链路层
数据链路层在通信实体间建立数据链路连接，物理设备连接完成以后，需要相应的软件和驱动来连接和打通这些物理设备，创建电路的连接。

### 物理层：
定义物理设备如何传输数据，常见的物理层有网线，光缆，网卡，声卡等，物理层是一切软件的基础。

## 访问网页时发生了什么
1. 用户在浏览器地址栏中输入对应网址的 `url` 然后回车。
2. 浏览器会首先判断是否需要 `redirect`。
3. 浏览器去 `app-cache` 中查找是否有缓存，如果有，则查找本地缓存；否则需要继续去服务器请求对应文件。
4. 因为用户输入的是域名，每个域名都需要映射到一台服务器的 `IP` 地址，客户端需要拿到对应服务器的 `IP` 才能进行后续的连接与请求。如果本地没有记录过这个域名和 `IP` 的映射，客户端就需要去对应的域名供应商哪里去获取服务器 `IP` ，这个过程叫做 `DNS 解析`。
5. 浏览器从域名供应商那里获取到了服务器对应 `IP`，就会向服务器发送 `TCP` 连接请求，服务器收到请求后回应，双方确认后建立起 `TCP 双向连接`。从客户端发起连接请求一直到 `TCP` 连接建立，这个过程，叫做 `三次握手`。
6. 如果请求是 HTTPS 的，还需要在 `TCP` 连接上，再通过 `SSL` 或 `TLS` 提供加密处理数据、验证对方身份以及数据完整性，来保证数据传输的安全。
7. 连接创建完成，浏览器开始向服务端发送 HTTP 请求的数据包，服务端接受请求，对请求进行解析，经过数据操作后，返回客户端需要的数据包。
8. 客户端接收到服务端返回的数据包，开始页面的渲染。至此，一次 HTTP 请求完成。

## HTTP 协议是什么
> `HTTP` 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，它通常运行在 `TCP` 之上，通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定。也就是说，http协议规定了超文本传输所要遵守的规则。

1. **HTTP 协议是无状态的**。这意味着客户端和服务端之间无法知晓当前对方的状态信息，`HTTP` 请求本身是不带有任何状态存储的。但实际情况下，客户端和服务端必然需要状态的认证和交互，所以就引入了 `Cookie`， 用于存储当前浏览器的一些状态信息，每次通过独立的 `HTTP` 请求进行收发，从而解决这个问题。
2. **HTTP 请求互相独立**。`HTTP` 互相之间都是一个独立的个体请求，在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应 `HTML` 页面，然后浏览器收到响应之后发现页面还引用了其他的资源，例如，CSS，JS文件，图片等等，还会自动发送 `HTTP` 请求获取这些需要的资源。
3. **HTTP 协议基于TCP协议**。`HTTP` 协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节,底层是基于 `TCP` 实现的。现在使用的版本当中是默认持久连接的，也就是多次 `HTTP` 请求使用一个 `TCP` 连接。

## HTTP 协议发展历史
### HTTP 0.9 版本
- 只有一个 `GET` 命令。
- 没有请求头和响应头来描述传输相关的数据信息。
- 服务器发送完数据后，直接关闭 `TCP` 连接，不支持 `TCP` 持久化连接。

### HTTP 1.0 版本
- 增加了很多命令，`HEAD`、`POST`、`PUT`、`DELETE` 等。
- 增设了 `status code` 状态码和 `header` 请求头和响应头。
- 增加了多字符集支持、多部分发送、权限、缓存等。

### HTTP 1.1 （目前普遍使用）
- 默认支持持久连接
- 默认支持长连接（PersistentConnection），即默认开启 `Connection： keep-alive`。
- 支持请求的流水线（Pipelining）处理，即在一个 `TCP` 连接上可以传送多个 `HTTP` 请求和响应。
- 增加了 `host` 请求头字段，通过对 `host` 解析，就能够允许在同一台物理服务器上运行多个软件服务，极大提高了服务器的使用率。目前的 `nginx` 反向代理就是根据 `HTTP` 请求头中的 `host` 来分辨不同的请求，从而将这些请求代理到同一台服务器不同的软件服务上。

### HTTP 2.0
- 使用二进制的数据传输方式来替代 `HTTP 1` 中的字符串数据传输方式。
- 所有数据以“帧”的方式进行传输，因此同一个连接中发送的多个请求不再需要按照顺序进行返回处理，可以达到并发的数据传输。
- 压缩头信息进行传输数据量的优化。
- 新增了推送的概念，服务端可以主动发起一些数据推送。比如，服务端在接收到浏览器发来的 `HTML` 请求的同时，可以主动推送相关的资源文件（js/css）给客户端，并行发送，提高网页的传输和渲染效率。

### HTTPS
`HTTPS` 其实就是一个安全加强版的 `HTTP 1.1` 有几点需要注意的是：
1. `HTTPS` 协议需要到 `CA` 申请证书，一般免费证书很少，需要交费
2. `HTTP` 协议运行在 `TCP` 之上，所有传输的内容都是明文，`HTTPS` 运行在 `SSL/TLS` 之上，`SSL/TLS` 运行在 `TCP` 之上，所有传输的内容都经过加密的。
3. `HTTP` 和 `HTTPS` 使用的是完全不同的连接方式，用的端口也不一样，前者是 **80**，后者是 **443**。
4. `HTTPS` 可以有效的防止运营商劫持，解决了防劫持的一个大问题。

## TCP/IP 协议族
关于 `TCP/IP` ，有个故事让我记忆犹新。那个时候我刚毕业进入一家互联网公司不久，一天安卓组主管刚面试完回来，我就听到别的同事问他：“咋样，这人行不？” 。他说：“不行不行，连 `TCP/IP` 都不懂，怎么能过面试？”
我听的老脸一红，心想 `TCP/IP` 是啥，妈的我也不懂啊😂😂😂，于是赶紧找博客看，那个时候压根不知道这玩意有啥用处，只好硬着头皮看，知识囫囵吞枣根本不过脑。后来随着工作内容逐渐深入，才发现这玩意的重要性。作为我们经常打交道的 `HTTP` 请求所依附的基础，我们有必要了解一下 `TCP/IP`。

> TCP/IP协议（传输控制协议/互联网协议）不是简单的一个协议，而是一组特别的协议，包括：TCP，IP，UDP，ARP等，这些被称为子协议。在这些协议中，最重要、最著名的就是TCP和IP。因此，大部分网络管理员称整个协议族为“TCP/IP”。

- **TCP 协议**
    - `TCP` 协议是面向连接的全双工协议，因此不管是客户端还是服务端都能在 `TCP` 连接通道下向对端接收和发送数据。
    - `TCP` 相比于 `UDP` 的优势在于它的传输稳定性，在数据传输之前必须经过三次握手建立连接；在数据传输过程中必须保证数据有序完整地传到对端。
    - `TCP` 相比于 `UDP` 的劣势在于它的复杂度，连接建立、断开都是比较大的性能开销，而且数据传输过程中一旦卡住，则必须等前面的数据发送完毕以后，后续数据才能继续传输。
    - 每台服务器可提供支持的 `TCP` 连接数量是有限的，所以这也使得 `TCP` 连接变成了稀缺资源，经不起浪费。
- **UDP 协议**
    - `UDP` 协议是面向无连接的，不需要在传输数据前先建立连接，想发就发想传就传。
    - `UDP` 做的工作只是报文搬运，不负责有序且不丢失地传递到对端，因此容易出现丢包的情况。
    - `UDP` 不仅支持一对一的传输方式，还支持一对多、多对多、多对一的方式，也就是说 `UPD` 提供了单播、多播、广播的功能。
    - `UDP` 相比于 `TCP` 的优势在于它的轻量、高效和灵活，在一些对于实时性应用要求较高的场景下需要使用到 `UDP`，比如直播、视频会议、LOL等实时对战游戏。
    - `UDP` 相比于 `TCP` 的劣势在于它的不可靠性和不稳定性。
    
## TCP 连接    
在客户端和服务端互相发送接受数据之前，即在正式发送 `HTTP` 请求之前，需要先创建一个 `TCP` 连接，在创建的 `TCP Connect`  通道下，`HTTP` 请求和响应才能正常的发送和接受，`HTTP` 只负责传输数据包，并没有连接的概念，因此 `HTTP` 也被叫做“无状态协议”。
在不同的 `HTTP` 协议版本里，这个 `TCP` 连接通道的创建机制也有所不同。
- 在 `HTTP1.0` 中，每一次 `HTTP` 请求都会创建一个 `TCP` 连接，在请求发送完成，服务器响应以后，这个 `TCP` 连接就自动断开了。
- 在 `HTTP1.1` 中，可以通过设置 `Connection： keep-alive` 来建立 `TCP` 的持久连接，多个 `HTTP` 请求可以共用一个 `TCP` 连接。
- 在 `HTTP2` 中，`TCP` 连接支持并发请求。

> 注意：`HTTP` 请求和 `TCP` 连接是不一样的，`HTTP` 是在 `TCP` 连接建立的基础上而发起的传输请求，在同一个 `TCP` 连接通道下，可以发送多个 `HTTP` 请求，举个例子的话就是高速公路和车子的关系。


## TCP 的三次握手和四次挥手
### 三次握手

![TCP 的三次握手](https://github.com/CRONWMMM/IT-output/blob/master/images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg)

> 提示：关于 `ACK`、`FIN`、`SYN` 状态码的含义
> 1. `ACK` 用于确认，表示通知对方，我已经收到你发来的信息了。
> 2. `FIN` 用于结束，表示告知对方，我这边已经结束，数据全部发送完毕，没有后续输出，请求终止连接。
> 3. `SYN` 用于同步和建立连接，表示告知对方，我这边请求同步建立连接。

1. 第一次握手：由客户端向服务端发送连接请求 `SYN` 报文，该报文段中包含自身的数据通讯初始序号，请求发送后，客户端便进入 `SYN-SENT` 状态。
2. 第二次握手：服务端收到连接请求报文段后，如果同意连接，**则会发送一个包含了 `ACK` 和 `SYN` 报文信息的应答，该应答中也会包含自身的数据通讯初始序号**（在断开连接的“四次挥手”时，`ACK` 和 `SYN` 这两个报文是作为两次应答，独立开来发送的，因此会有四次挥手），服务端发送完成后便进入 `SYN-RECEIVED` 状态。
3. 第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 `ESTABLISHED` 状态，服务端收到这个应答后也进入 `ESTABLISHED` 状态，此时连接建立成功。

> 面试时可能会问的一个问题就是，明明两次握手就能确定的连接，为什么需要三次握手？
> 因为由于很多不可控制的因素，例如网络原因，可能会造成第一次请求隔了很久才到达服务端，这个时候客户端已经等待响应等了很久，之前发起的请求已超时，已经被客户端废弃掉不再继续守着监听了。
> 然而服务端过了很久，收到了废弃的延迟请求，发起回应的同时又开启了一个新的 `TCP` 连接端口，在那里呆等客户端。
> 而服务端能维护的 `TCP` 连接是有限的，这种闲置的无用链接会造成服务端的资源浪费。
> 因此在服务端发送了 `SYN` 和 `ACK` 响应后，需要收到客户端接的再次确认，双方连接才能正式建立起来。三次握手就是为了规避这种由于网络延迟而导致服务器额外开销的问题。

### 四次挥手

![TCP 的四次挥手](https://github.com/CRONWMMM/IT-output/blob/master/images/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg)

和建立 `TCP` 连接类似，断开 `TCP` 连接也同样需要客户端于服务端的双向交流，因为整个断开动作需要双端共发送 4 个数据包才能完成，所以简称为“四次挥手”。
1. 第一次挥手：客户端认为自己这边的数据已经全部发送完毕了，于是发送一个 `FIN` 用来关闭客户端到服务端的数据传输，发送完成以后，客户端进入 `FIN_WAIT_1` 状态。
2. 第二次挥手：服务端收到客户端发送回来的 `FIN` 以后，会告诉应用层要释放 TCP 链接，并且发送一个 `ACK` 给客户端，表明已经收到客户端的释放请求了，不会再接受客户端发来的数据，自此，服务端进入 `CLOSE_WAIT` 的状态。
3. 第三次挥手：服务端如果此时还有未发送完的数据可以继续发送，发送完毕后，服务端也会发送一个释放连接的 `FIN` 请求用来关闭服务端到客户端的数据传送，然后服务端进入 `LAST_ACK` 状态。
4. 第四次挥手：客户端接收到服务端的 `FIN` 请求后，发送最后一个 `ACK` 给服务端，接着进入 `TIME_WAIT_2` 状态，该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，客户端就进入 `CLOSED` 状态.服务端在收到应答消息后，也会进入 `CLOSED` 状态，至此完成四次挥手的过程，双方正式断开连接。

上面的内容可能还是有些不够直观，所以我还准备了一段人话来描述整个过程：
1. 客户端：喂，我好了。
2. 服务端：噢，你好了是吧，我知道了，我还没好，你等一哈。
3. 服务端：OK，现在我也好了。
4. 客户端：收到，这次玩的很开心，我们下次再约。

> 可能有些面试中会问，为什么建立连接有三次握手，而断开连接却有四次？
> 这是因为在建立连接过程中，服务端在收到客户但建立连接请求的 `SYN` 报文后，会把 `ACK` 和 `SYN` 放在一个报文里发送给客户端。
> 而关闭连接时，服务端收到客户端的 `FIN` 报文，只是表示客户端不再发送数据了，但是还能接收数据，而且这会儿服务端可能还有数据没有发送完，不能马上发送 `FIN` 报文，只能先发送 `ACK` 报文，先响应客户端，在确认自己这边所有数据发送完毕以后，才会发送 `FIN`。
> 所以，在断开连接时，服务器的 `ACK` 和 `FIN` 一般都会单独发送，这就导致了断开连接比请求连接多了一次发送操作。

### HTTP 报文
![HTTP报文格式](https://github.com/CRONWMMM/IT-output/blob/master/images/HTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.jpg)

`HTTP` 是以请求和响应的形式存在的，由于发起方主动发起一个 `HTTP` 请求，然后由响应方回应，双方按照一定的报文格式进行数据的互传，上图是 `HTTP` 请求和响应包文的大概格式，由“首行”、“首部”和“主体”构成。

#### 首行
首行并不属于 `Http Headers` ，它包含了：
1. **HTTP Method**（`GET`、`POST`、`PUT`、`DELETE` 等 ），不同的 `HTTP Method` 有不同的语意。

    HTTP Method | 对应予以
    ---         | ---
    GET         | 一般用于获取服务器资源
    POST        | 一般用于传输实体主体
    PUT         | 一般用于传输文件
    DELETE      | 用于删除文件
    HEAD        | 用于获取报文首部，不返回报文主体
    OPTIONS     | 用于询问请求URI资源支持的方法
    
    > `HTTP Method` 只是 `HTTP` 协议推崇的一种规范，就像 `ESLint`，你可以选择遵循，也可以选择不遵循，它们所作的事情实质上没有差别，只是语义化更明确。 
    
2. **URL**请求资源的地址，这个地址只会包含请求的路由地址。
3. **协议的版本**，`HTTP 1.0 / HTTP 1.1 / HTTP 2`。
4. **HTTP 返回状态码**（响应报文首行包含）
    > `HTTP` 定义了40个标准状态代码，可用于传递客户端请求的结果，状态代码分为以下五类，关于各个分段下的返回状态码信息可以参考 [HTTP 响应码](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)：
    
    ![HTTP 返回码](https://github.com/CRONWMMM/IT-output/blob/master/images/HTTP%E8%BF%94%E5%9B%9E%E7%A0%81%EF%BC%88%E5%A4%A7%E7%B1%BB%EF%BC%89.jpg)
    
    > 这边需要注意的一点是，一个好的 HTTP 应用服务应该是有完善的 HTTP status code 的返回信息的，即访问者单从 HTTP status code 上就能得知当前 HTTP 请求的状态信息。
    而目前我们大部分的开发模式下的 HTTP 返回码，只有 `200` 和 `500`。服务端的同学会先把 `200` 返回过来，然后再告诉你出了什么 “没登录” / “没认证” / “没权限” 这一类的问题。
    业界也有一句戏言：**又不是不能用**，其实这种开发方式是不正确的，不管从代码的维护性还是个人自身发展角度，我们都需要尽量避免这种问题。
    
#### 首部
首部，即 `HTTP Header`，首部换行后的信息都是 `HTTP Header`

#### 主体
主体，即 `HTTP body`，HTTP Header` 信息和主体信息间以一个空行 + 一个换行来区分。

#### HTTP status code
HTTP status code

## URI、URL 和 URN
既然说到 `HTTP` 就不得不提一嘴 `URI`、`URL` 和 `URN`，在网络世界里，所有资源的存在地址都是被标识且唯一的，`HTTP` 存在的价值，就是通过这些资源地址，以某种方式获取和操作这些资源实体。
先来看一张图：

![URI、URL和URN](https://github.com/CRONWMMM/IT-output/blob/master/images/URI_URL_URN.jpg)

### URI 
 - Uniform Resource Identifier，统一资源标识符，简称为 `URI`。
 - 每个 Web 服务器都有一个 `URI` 标识符，它在世界范围内唯一标识并定位信息资源，一个资源信息有了 `URI` 标识以后，在互联网上就能通过一个固定的地址访问到这个资源。
 - 它具有两种形式，URN （统一资源名）、URL（统一资源定位符），也就是说 `URL` 和 `URN` 是它的子集。

### URL
Uniform Resource Locator，统一资源定位符，简称 `URL`，下图是一个完整的 `URL` 组成。

![URL 完整组成格式](https://github.com/CRONWMMM/IT-output/blob/master/images/URL%E5%AE%8C%E6%95%B4%E7%BB%84%E6%88%90%E6%A0%BC%E5%BC%8F.jpg)

一个完整的 `URL` 从左到右包含如下部分：
1. **schema** 标识了这个资源地址所基于的访问协议，常见的比如：`HTTP` 和 `FTP`。
2. **user information** 标识了用户信息（如果这个资源需要用户信息认证的话），不过一般现在的认证都不采用这种方式，一来输入非常麻烦，二来不安全。
3. **host** 标识了资源的域信息，可以是域名，也可以是 `IP` ，这块的作用主要是找到资源所存放的物理服务器地址。
4. **port** 端口号，一个物理服务器，通过开启不同的端口，就同时可以运行多个 web 服务器，资源文件会部署在某一个 web 服务器的某一个地方，而端口号就是用来定位资源存在的 web 服务器的。
5. **path** 路径，或者叫路由，一个 web 服务器下有许多目录，一般 path 就是用来定位到资源文件所存放的目录的。由于现在很多的 web 应用非常庞大，这个路径也不一定就是目录地址，也可能是 web 服务器指定的静态资源文件的请求地址。
6. **query** 查询字符串，一般用于 `GET` 查询，传递查询参数。
7. **fragment** 片段，哈希，或者叫锚点，主要用于前端文档的定位，或者是前端渲染时控制路由跳转的手段。

> 这里需要注意将 `URL` 与网址区别开来。
> `URL` 不仅仅包含了网页的资源地址，还包含了组成网页所需的图片、视频等超文本资源，以及 css js 等资源地址。
> 网址本质上是 `IP` 地址的一个更有辨别度的映射，在通过 `DNS` 解析之后，浏览器最先拿到的是 html 文档的 `URL` 地址，根据浏览器对 Html 文档的解析，继续通过网页内其他资源文件的 `URL` 获取对应的资源文件。

### URN
Uniform Resource Name，统一资源名称，简称 `URN`，它的用处简单说就是永久定位资源，因为同一个资源可能会更换存储位置，存储位置一旦更换，再访问原来的 url 肯定是拿不到的，URN 就是解决这个问题的，不管资源位置怎么移动，只要访问同一个 `URN` 都能定位到。

## CORS 跨域
> 浏览器的同源限制：当**浏览器**访问 URL 地址的**协议（schema）/ 端口（port）/ 域名（host）**，三者中有任何一个与当前的 URL 片段信息不匹配的时候，跨域问题就出现了。

当前地址                   | 请求地址                   | 请求是否成功
---                       | ---                       | ---
https://www.juejin.com:80 | http://www.juejin.com:80  | 失败（协议不同）
https://www.juejin.com:80 | https://www.juejin.cn:80  | 失败（域名不同）
https://www.juejin.com:80 | https://www.juejin.com:90 | 失败（端口不同）

对于跨域的两点需要明确：
1. **跨域，是浏览器提供的一种保护手段**，服务端是不存在跨域这一说的。这也就是为什么现在前后端分离的开发模式下，前端比较依赖 `webpack-dev-server` 启动代理服务来中转和代理后台接口的原因，因为两个服务器之间相互通信是没有跨域障碍的。
2. **跨域，是对于 Ajax 请求来说的，浏览器获取不同源服务器下的静态资源，是没有跨域限制的**，这也是 `JSONP` 跨域请求得以实现的本质。

> 当浏览器向不同域的服务器发送请求时，请求是真能发出去，对方服务端也是真能接收到请求，并且真能给你的浏览器响应，浏览器也真能接收到有效数据。
> 但是，如果在跨域的情况下、服务端返回数据的响应头里的 `Access-Control-Allow-Origin` 字段，没有把当前域名列进白名单，那么浏览器会把服务端返回的数据给藏起来，不告诉你，然后给你抛个 `Access-Control-Allow-Origin` 的错误。

> 至于为什么资源文件不受同源策略限制呢？可以试想一下，如果资源文件也被限制跨域，那么现在大量使用的 CDN 缓存策略基本就没办法用了。而且现在很多网站的资源文件，都会放到云服务器的 OSS 上，OSS 资源对应的 url 地址肯定是不同域的，那这些资源也不能使用了。

### Access-Control-Allow-Origin
`Access-Control-Allow-Origin` 标识了服务器允许的跨域白名单，它有以下几种设置方法：
1. 直接设置 `*` 通配符，简单粗暴，但是这么做等于把服务器的所有接口资源对外完全暴露，是不安全的。
2. 设置制定域，比如 `Access-Control-Allow-Origin: https://www.baidu.com` ，这样只会允许指定域的请求进行跨域访问。
3. 由后端动态设置。`Access-Control-Allow-Origin` 限制只能写一个白名单，但是当我们有多个域都需要跨域请求怎么呢？这个时候，这时可以由服务端自己维护一套白名单列表，在请求进来的时候对请求的源 `host` 进行白名单比对，如果在白名单中，就将这个 `Access-Control-Allow-Origin` 动态设置上去，然后返回响应。

### CORS 的预请求
如果我们像上面一样，只设置的 `Access-Control-Allow-Origin` 白名单，是否就可以完全畅通无阻地进行跨域了呢？并不是。
就算对端开启了域名白名单认证，然鹅有一些操作仍然是需要进一步认证的，这种进一步的认证操作，就是 `CORS 预请求`。

#### 预请求触发过程
浏览器预请求的触发条件，**是判断本次请求是否属于一个简单请求**。
如果本次请求属于一个**复杂请求**，那么在发送正式的跨域请求之前，浏览器会先准备一个名为 `OPTIONS` 的 `HTTP Method` ，作为预请求发送。
在服务器通过预请求后，下面浏览器才会发生正式的数据请求。整个请求过程其实是发生了两次请求：一个预检请求，以及后续的实际数据请求。

![OPTIONS预请求案例](https://github.com/CRONWMMM/IT-output/blob/master/images/OPTIONS预请求案例.jpg)

##### 简单请求
1. 请求方式只能是 `GET` `POST` `HEAD`
2. 请求头字段只允许：
    - `Accept`
    - `Accept-Language`
    - `Content-Language`
    - `Content-Type`
3. `Content-Type` 的值仅限于：
    - `text/plain`
    - `multipart/form-data`
    - `application/x-www-form-urlencoded`
4. `XMLHttpRequestUpload` 对象均没有注册任何事件监听器（了解就好）。
5. 请求中没有使用 `ReadableStream` 对象（了解就好）。

##### 复杂请求
除了简单请求里定义的，都是复杂请求，统统需要预请求。

#### 预请求的验证
那么怎样使预检请求成功认证呢？还是需要服务端继续帮忙设置请求头的白名单：

1. `Access-Control-Allow-Headers`，设置允许的额外请求头。
2. `Access-Control-Allow-Methods`，设置允许的额外请求方法。
3. `Access-Control-Max-Age` （单位/秒），指定了预请求的结果能够被缓存多久，在这个时间范围内，再次发送跨域请求不会被预检。

> 更多、更具体的跨域限制策略可以[点击这里查看更多](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)

## HTTP 性能优化

影响 HTTP 网络请求的因素主要有两个：**带宽和延迟**。
1. 目前的服务商提供的带宽动不动就是 100M 200M，带宽的对于 `HTTP` 请求速度的影响已经很小了。如果带宽依旧不够，推荐升级带宽。
2. 延迟：
    - **浏览器阻塞**：浏览器对于同一个域名，同时开放的连接数是有限的，如果请求数量比较多，后续的请求就先被阻塞。
    - **DNS查询**：为了拿到服务器的 IP ，浏览器会拿着域名去做 `DNS 解析`，这个过程也会耗时，一般可以通过利用 `DNS 缓存` 来做这方面的优化处理。
    - **建立 TCP 连接**：TCP 连接的建立需要经过两端三次握手确认，这也是属于长耗时操作。
> 从在浏览器 url 地址栏输入回车到页面渲染完成的一张流程图，
> 每一个节点就是 HTTP 做的一件重要的事情，开发者可以根据每个节点，进行优化从而达到性能的提升。

浏览器控制台里有一个选项 `performence` ，它会为我们记录 HTTP 请求发起到页面渲染完成这段过程中的每一个过程点，在 HTTP 请求和浏览器渲染的过程中存在着时间的消耗，这个 `performence`，可以为我们记录每个时间点上所消耗的时间。
对于开发者来说，我们通过 `performence` 记录的过程节点，就可以清楚地看到哪个过程耗时比较长，就可以有针对地进行优化。

## Cache-Control 缓存

### 缓存读取策略

前端环境下的文件缓存，分为几个不同的位置。当我们打开 Chrome 控制台，查看 Network 下每条请求记录的 size 选项，会发现非常丰富的来源信息。

![缓存位置图示](https://github.com/CRONWMMM/IT-output/blob/master/images/%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE.jpg)

对于前端浏览器环境来说，缓存读取位置是由先后顺序的，顺序分别是（由上到下寻找，找到即返回；找不到则继续）
- Service Worker
- Memory Cache
- Disk Cache
- 网络请求

> **缓存头是指**：`response` 的返回结果可被中间经过的各代理服务器以及请求浏览器缓存，是前端开发中重要的缓存优化方式之一。
> **缓存的意义**：不需要每次都到业务服务器去请求数据，只需要在中间缓存中获取即可，提升了获取数据效率及响应速度，数据变化频率很快的场景并不适合开启 `Cache-Control`。

指令               | 作用
---               | ---
public            | 表示响应的资源可以同时被客户端和代理服务器缓存
private           | 表示响应的资源只能够被发起请求的客户端缓存
max-age           | （单位/秒）设置缓存的过期时间，过期需要重新请求，否则就读取本地缓存，并不实际发送请求
s-maxage          | （单位/秒）覆盖 max-age，作用一样，只在代理服务器中生效
max-stale         | （单位/秒）表示即使缓存过期，也使用这个过期缓存
no-store          | 不做任何缓存
no-transform      | 
no-cache          | 做缓存，但是每次使用本地缓存之前，需要请求服务器，查看缓存是否失效
must-revalidate   | 当缓存过期，必须发送请求到服务端重新获取数据
proxy-revalidate  | 

![Cache-Control 流程图](https://github.com/CRONWMMM/IT-output/blob/master/images/Cache-Control.jpg)

## 缓存校验
> 在缓存中，我们需要一个机制来验证缓存是否有效。比如服务器的资源更新了，客户端需要及时刷新缓存；又或者客户端的资源过了有效期，但服务器上的资源还是旧的，此时并不需要重新发送。
> 缓存校验就是用来解决这些问题的，在http 1.1 中，我们主要关注下 `Last-Modified` 和 `ETag` 这两个字段。

## 相关面试题汇总
