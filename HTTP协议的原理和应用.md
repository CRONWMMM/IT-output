# 【基础】HTTP协议的原理及应用

## 前言
HTTP 非常重要和基础

## 经典网络五层模型
![经典网络五层模型](https://github.com/CRONWMMM/IT-output/blob/master/images/%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B.png)

在每台计算机设备上，都有这么一套系统链路的关系，来保证网络传输的正常进行，因为统一集成了这么一套经典模型，所以自己使用的计算机也是可以作为一台服务器来提供网络服务的。

### 应用层：
应用层包含了我们所说的 `HTTP` 协议，为各个应用软件提供了很多服务，常见的应用层服务有：`HTTP` 服务 、`FTP` 服务 、`Email` 服务`HTTP` 等。应用层屏蔽了底层模型的相关细节，作为应用支持，只提供给使用者一些必要的使用方式。

### 传输层
传输层作为为应用层的基础，定义了“端到端（end to end）”之间数据间的传输方式，比如：两台设备如何建立连接？设备之间需要以何种规范进行数据传输？需要以什么方式进行数据的分片、重组、拼接？这些都是传输层为我们定义好的。

### 网络层
网络层为数据在结点之间传输创建逻辑链路，当我们在浏览器敲下域名，浏览器在网络里如何通过这个域名，找到对应的 `IP` 映射，这个查询的逻辑关系和链路，是网络层规范和定义的。

### 数据链路层
数据链路层在通信实体间建立数据链路连接，物理设备连接完成以后，需要相应的软件和驱动来连接和打通这些物理设备，创建电路的连接。

### 物理层：
定义物理设备如何传输数据，常见的物理层有网线，光缆，网卡，声卡等，物理层是一切软件的基础。

## 访问网页时发生了什么
1. 用户在浏览器地址栏中输入对应网址的 `url` 然后回车。
2. 浏览器会首先判断是否需要 `redirect`。
3. 浏览器去 `app-cache` 中查找是否有缓存，如果有，则查找本地缓存；否则需要继续去服务器请求对应文件。
4. 因为用户输入的是域名，每个域名都需要映射到一台服务器的 `IP` 地址，客户端需要拿到对应服务器的 `IP` 才能进行后续的连接与请求。如果本地没有记录过这个域名和 `IP` 的映射，客户端就需要去对应的域名供应商哪里去获取服务器 `IP` ，这个过程叫做 `DNS 解析`。
5. 浏览器从域名供应商那里获取到了服务器对应 `IP`，就会向服务器发送 `TCP` 连接请求，服务器收到请求后回应，双方确认后建立起 `TCP 双向连接`。从客户端发起连接请求一直到 `TCP` 连接建立，这个过程，叫做 `三次握手`。
6. 如果请求是 HTTPS 的，还需要在 `TCP` 连接上，再通过 `SSL` 或 `TLS` 提供加密处理数据、验证对方身份以及数据完整性，来保证数据传输的安全。
7. 连接创建完成，浏览器开始向服务端发送 HTTP 请求的数据包，服务端接受请求，对请求进行解析，经过数据操作后，返回客户端需要的数据包。
8. 客户端接收到服务端返回的数据包，开始页面的渲染。至此，一次 HTTP 请求完成。

## HTTP 协议是什么
> `HTTP` 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，它通常运行在 `TCP` 之上，通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定。也就是说，http协议规定了超文本传输所要遵守的规则。

## HTTP 协议的特点
1. **HTTP 协议是无状态的**。这意味着客户端和服务端之间无法知晓当前对方的状态信息，`HTTP` 请求本身是不带有任何状态存储的。但实际情况下，客户端和服务端必然需要状态的认证和交互，所以就引入了 `Cookie`， 用于存储当前浏览器的一些状态信息，每次通过独立的 `HTTP` 请求进行收发，从而解决这个问题。
2. **HTTP 请求互相独立**。`HTTP` 互相之间都是一个独立的个体请求，在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应 `HTML` 页面，然后浏览器收到响应之后发现页面还引用了其他的资源，例如，CSS，JS文件，图片等等，还会自动发送 `HTTP` 请求获取这些需要的资源。
3. **HTTP 协议基于TCP协议**。`HTTP` 协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节,底层是基于 `TCP` 实现的。现在使用的版本当中是默认持久连接的，也就是多次 `HTTP` 请求使用一个 `TCP` 连接。

## HTTP 协议发展历史
### HTTP 0.9 版本
- 只有一个 `GET` 命令
- 没有请求头和响应头来描述传输相关的数据信息
- 服务器发送完数据后，直接关闭 `TCP` 连接
> 注意：`HTTP` 请求和 `TCP` 连接是不一样的，`HTTP` 是在 `TCP` 连接建立的基础上而发起的传输请求，在同一个 `TCP` 连接通道下，可以发送多个 `HTTP` 请求，举个例子的话就是高速公路和车子的关系。

### HTTP 1.0 版本
- 增加了很多命令，`HEAD`、`POST`、`PUT`、`DELETE` 等。
- 增设了 `status code` 状态码和 `header` 请求头和响应头。
- 增加了多字符集支持、多部分发送、权限、缓存等。

### HTTP 1.1 （目前普遍使用）
- 默认支持持久连接
- 增加了 `pipeline` ，允许并行处理请求
- 增加了 `host` 请求头字段，通过对 `host` 解析，就能够允许在同一台物理服务器上运行多个软件服务，极大提高了服务器的使用率。目前的 `nginx` 反向代理就是根据 `HTTP` 请求头中的 `host` 来分辨不同的请求，从而将这些请求代理到同一台服务器不同的软件服务上。
> HTTP是基于 `TCP/IP` 协议的，创建一个 `TCP` 连接是需要经过三次握手，有比较大的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发送多个请求。

### HTTP 2.0
- 使用二进制的数据传输方式来替代 `HTTP 1` 中的字符串数据传输方式。
- 所有数据以“帧”的方式进行传输，因此同一个连接中发送的多个请求不再需要按照顺序进行返回处理，可以达到并发的数据传输。
- 压缩头信息进行传输数据量的优化。
- 新增了推送的概念，服务端可以主动发起一些数据推送。比如，服务端在接收到浏览器发来的 `HTML` 请求的同时，可以主动推送相关的资源文件（js/css）给客户端，并行发送，提高网页的传输和渲染效率。
> HTTP 2 的升级，主要是为了解决 HTTP 1 中存在的性能瓶颈而做的一些调整和优化。

### HTTPS
`HTTPS` 是一个安全版的 `HTTP 1.1` 。

## TCP/IP 协议族
作为 `HTTP` 的依附基础，我们有必要了解一下 `TCP/IP`。
> TCP/IP协议（传输控制协议/互联网协议）不是简单的一个协议，而是一组特别的协议，包括：TCP，IP，UDP，ARP等，这些被称为子协议。在这些协议中，最重要、最著名的就是TCP和IP。因此，大部分网络管理员称整个协议族为“TCP/IP”。

- **TCP 协议**
    - `TCP` 协议是面向连接的全双工协议，因此不管是客户端还是服务端都能在 `TCP` 连接通道下向对端接收和发送数据。
    - `TCP` 相比于 `UDP` 的优势在于它的传输稳定性，在数据传输之前必须经过三次握手建立连接；在数据传输过程中必须保证数据有序完整地传到对端。
    - `TCP` 相比于 `UDP` 的劣势在于它的复杂度，连接建立、断开都是比较大的性能开销，数据传输过程中一旦卡住，则必须等前面的数据发送完毕以后，后续数据才能继续传输。
    - 每台服务器可提供支持的 `TCP` 连接数量是有限的。
- **UDP 协议**
    - `UDP` 协议是面向无连接的，不需要在传输数据前先建立连接。
    - `UDP` 做的工作只是报文搬运，不负责有序且不丢失地传递到对端，因此容易出现丢包的情况。
    - `UDP` 不仅支持一对一的传输方式，还支持一对多、多对多、多对一的方式，也就是说 `UPD` 提供了单播、多播、广播的功能。
    - `UDP` 相比于 `TCP` 的优势在于它的轻量、高效和灵活，在一些对于实时性应用要求较高的场景下需要使用到 `UDP`，比如直播、视频会议、LOL等实时对战游戏。
    - `UDP` 相比于 `TCP` 的劣势在于它的不可靠性和不稳定性。
    
## TCP 的三次握手和四次挥手
### 三次握手
在客户端和服务端互相发送接受数据之前，即在正式发送 `HTTP` 请求之前，需要先创建一个 `TCP` 连接，在创建的 `TCP Connect`  通道下，`HTTP` 请求和响应才能正常的发送和接受，`HTTP` 只负责传输数据包，并没有连接的概念，因此 `HTTP` 也被叫做“无状态协议”。
在不同的 `HTTP` 协议版本里，这个 `TCP` 连接通道的创建机制也有所不同。
- 在 `HTTP1.0` 中，每一次 `HTTP` 请求都会创建一个 `TCP` 连接，在请求发送完成，服务器响应以后，这个 `TCP` 连接就自动断开了。
- 在 `HTTP1.1` 中，可以通过设置 `Header` 中的 `Keep-Alive` 来建立 `TCP` 的持久连接，多个 `HTTP` 请求可以共用一个 `TCP` 连接。
- 在 `HTTP2` 中，`TCP` 连接支持并发请求。

![TCP 的三次握手](https://github.com/CRONWMMM/IT-output/blob/master/images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg)

1. 第一次握手：由客户端发送一个请求连接的数据包到服务端。
2. 第二次握手：服务端接受到客户端发送的请求连接数据包，然后开启一个连接端口，将确认连接的数据包返回给客户端。
3. 第三次握手：客户端接收到服务端的响应，再次发送确认请求给服务端，告知服务端正式建立连接。
> 大家可能有疑问，明明两次握手就能确定的连接，为什么需要三次握手？因为由于很多不可控制的因素，例如网络原因，可能会造成第一次请求隔了很久才到达服务端，这个时候客户端已经等待响应等了很久，过了超时时间，可能已经不需要发送请求了，然而服务端收到了废弃的延迟请求后，开启了一个新的端口，发起回应的同时又建立了 `TCP` 连接，在那呆等，会造成服务端的资源浪费，因此需要客户端接收到请求响应后再次确认，双方连接才能正式建立起来。三次握手就是为了规避由于网络延迟而导致服务器额外开销的问题。

### 四次挥手

![TCP 的四次挥手](https://github.com/CRONWMMM/IT-output/blob/master/images/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg)

和建立 `TCP` 连接类似，断开 `TCP` 连接也同样需要客户端于服务端的双向交流，因为整个断开动作需要双端共发送 4 个数据包才能完成，所以简称为“四次挥手”。
1. 第一次挥手：客户端发送一个 `FIN` 用来关闭客户端到服务端的数据传输，发送完成以后，客户端进入 `FIN_WAIT_1` 状态。
2. 第二次挥手：服务端收到客户端发送回来的 `FIN` 以后，发送一个 `ACK` 给客户端，并确认返回序号为 `收到的序号+1`，服务端进入 `CLOSE_WAIT` 的状态。
3. 第三次挥手：服务端发送一个 `FIN` 用来关闭服务端到客户端的数据传送，服务端进入 `LAST_ACK` 状态。
4. 第四次挥手：客户端接收到服务端的 `FIN` 后，进入 `TIME_WAIT_2` 状态，接着发送最后一个 `ACK` 给服务端，并将返回序号继续 `+1`，服务端收到消息后，进入 `CLOSED` 状态，完成四次挥手，双方正式断开连接。

有点难以理解是吧，所以我还准备了一段人话来描述整个过程：
1. 客户端：我好了。
2. 服务端：你好了是吧？我还没好，你等一哈。
3. 服务端：OK，现在我也好了。
4. 客户端：收到，这次玩的很开心，我们下次再约。

> 可能有些面试中会问，为什么建立连接有三次握手，而断开连接却有四次？
> 这是因为服务端在建立连接过程中的 `LISTEN` 状态下，收到建立连接请求的 `SYN` 报文后，把 `ACK` 和 `SYN` 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 `FIN` 报文时，
  仅仅表示对方不再发送数据了但是还能接收数据，自己也未必全部数据都发送给对方了。所以这种状态下，自己可以选择立即关闭，也可以选择继续发送一些数据给对方后，
  再发送 `FIN` 报文给对方来表示同意现在关闭连接。因此，在断开连接时，服务器的 `ACK` 和 `FIN` 一般都会单独发送。

> 关于 `ACK`、`FIN`、`SYN` 状态码的含义：
> 1. `ACK` 用于确认，表示通知对方，我已经收到你发来的信息了。
> 2. `FIN` 用于结束，表示通知对方，整个过程结束，我们可以不用互动了。
> 3. `SYN` 用于同步和发送当前状态，表示向对方发送一些正式的数据包/请求/信息等。

### HTTP 报文
![HTTP报文格式](https://github.com/CRONWMMM/IT-output/blob/master/images/HTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.jpg)

`HTTP` 是以请求和响应的形式存在的，有发起方主动发起一个 `HTTP` 请求，然后由响应方回应，双方按照一定的报文格式进行数据的互传，上图是 `HTTP` 请求和响应包文的大概格式，由“首行”、“首部”和主体构成。
1. 首行，首行并不属于 `Http Headers` ，包含了：
    - `HTTP Method`（`GET`、`POST`、`PUT`、`DELETE` 等 `HTTP Method` ）
    - 

## URI、URL 和 URN
### URI 
Uniform Resource Identifier/统一资源标志符

### URL
Uniform Resource Locator/统一资源定位器

## HTTP 请求

## HTTP 缓存

## HTTP 请求头

## HTTP 响应头

## HTTP 性能优化
> 从在浏览器 url 地址栏输入回车到页面渲染完成的一张流程图，
> 每一个节点就是 HTTP 做的一件重要的事情，开发者可以根据每个节点，进行优化从而达到性能的提升。

浏览器控制台里有一个选项 `performence` ，它会为我们记录 HTTP 请求发起到页面渲染完成这段过程中的每一个过程点，在 HTTP 请求和浏览器渲染的过程中存在着时间的消耗，这个 `performence`，可以为我们记录每个时间点上所消耗的时间。
对于开发者来说，我们通过 `performence` 记录的过程节点，就可以清楚地看到哪个过程耗时比较长，就可以有针对地进行优化。

## CORS 实现跨域

## HTTPS

## HTTPS 的创建过程

## 为什么 HTTPS 是相对安全的

## 什么是长链接，为什么需要长链接

## HTTPS 的信道复用及性能优化

## TCP 

## 三次握手

