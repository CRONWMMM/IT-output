# 【基础】HTTP协议的原理及应用

## 前言
HTTP 非常重要和基础

## 经典网络五层模型
![经典网络五层模型](https://github.com/CRONWMMM/IT-output/blob/master/images/%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B.png)

在每台计算机设备上，都有这么一套系统链路的关系，来保证网络传输的正常进行，因为统一集成了这么一套经典模型，所以自己使用的计算机也是可以作为一台服务器来提供网络服务的。

### 应用层：
应用层包含了我们所说的 `HTTP` 协议，为各个应用软件提供了很多服务，常见的应用层服务有：`HTTP` 服务 、`FTP` 服务 、`Email` 服务`HTTP` 等。应用层屏蔽了底层模型的相关细节，作为应用支持，只提供给使用者一些必要的使用方式。

### 传输层
传输层作为为应用层的基础，定义了“端到端（end to end）”之间数据间的传输方式，比如：两台设备如何建立连接？设备之间需要以何种规范进行数据传输？需要以什么方式进行数据的分片、重组、拼接？这些都是传输层为我们定义好的。

### 网络层
网络层为数据在结点之间传输创建逻辑链路，当我们在浏览器敲下域名，浏览器在网络里如何通过这个域名，找到对应的 `IP` 映射，这个查询的逻辑关系和链路，是网络层规范和定义的。

### 数据链路层
数据链路层在通信实体间建立数据链路连接，物理设备连接完成以后，需要相应的软件和驱动来连接和打通这些物理设备，创建电路的连接。

### 物理层：
定义物理设备如何传输数据，常见的物理层有网线，光缆，网卡，声卡等，物理层是一切软件的基础。

## 访问网页时发生了什么
1. 用户在浏览器地址栏中输入对应网址的 `url` 然后回车。
2. 浏览器会首先判断是否需要 `redirect`。
3. 浏览器去 `app-cache` 中查找是否有缓存，如果有，则查找本地缓存；否则需要继续去服务器请求对应文件。
4. 因为用户输入的是域名，每个域名都需要映射到一台服务器的 `IP` 地址，客户端需要拿到对应服务器的 `IP` 才能进行后续的连接与请求。如果本地没有记录过这个域名和 `IP` 的映射，客户端就需要去对应的域名供应商哪里去获取服务器 `IP` ，这个过程叫做 `DNS 解析`。
5. 浏览器从域名供应商那里获取到了服务器对应 `IP`，就会向服务器发送 `TCP` 连接请求，服务器收到请求后回应，双方确认后建立起 `TCP 双向连接`。从客户端发起连接请求一直到 `TCP` 连接建立，这个过程，叫做 `三次握手`。
6. 如果请求是 HTTPS 的，还需要在 `TCP` 连接上，再通过 `SSL` 或 `TLS` 提供加密处理数据、验证对方身份以及数据完整性，来保证数据传输的安全。
7. 连接创建完成，浏览器开始向服务端发送 HTTP 请求的数据包，服务端接受请求，对请求进行解析，经过数据操作后，返回客户端需要的数据包。
8. 客户端接收到服务端返回的数据包，开始页面的渲染。至此，一次 HTTP 请求完成。

## HTTP 协议是什么
> `HTTP` 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，它通常运行在 `TCP` 之上，通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定。也就是说，http协议规定了超文本传输所要遵守的规则。

1. **HTTP 协议是无状态的**。这意味着客户端和服务端之间无法知晓当前对方的状态信息，`HTTP` 请求本身是不带有任何状态存储的。但实际情况下，客户端和服务端必然需要状态的认证和交互，所以就引入了 `Cookie`， 用于存储当前浏览器的一些状态信息，每次通过独立的 `HTTP` 请求进行收发，从而解决这个问题。
2. **HTTP 请求互相独立**。`HTTP` 互相之间都是一个独立的个体请求，在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应 `HTML` 页面，然后浏览器收到响应之后发现页面还引用了其他的资源，例如，CSS，JS文件，图片等等，还会自动发送 `HTTP` 请求获取这些需要的资源。
3. **HTTP 协议基于TCP协议**。`HTTP` 协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节,底层是基于 `TCP` 实现的。现在使用的版本当中是默认持久连接的，也就是多次 `HTTP` 请求使用一个 `TCP` 连接。

## HTTP 协议发展历史
### HTTP 0.9 版本
- 只有一个 `GET` 命令
- 没有请求头和响应头来描述传输相关的数据信息
- 服务器发送完数据后，直接关闭 `TCP` 连接
> 注意：`HTTP` 请求和 `TCP` 连接是不一样的，`HTTP` 是在 `TCP` 连接建立的基础上而发起的传输请求，在同一个 `TCP` 连接通道下，可以发送多个 `HTTP` 请求，举个例子的话就是高速公路和车子的关系。

### HTTP 1.0 版本
- 增加了很多命令，`HEAD`、`POST`、`PUT`、`DELETE` 等。
- 增设了 `status code` 状态码和 `header` 请求头和响应头。
- 增加了多字符集支持、多部分发送、权限、缓存等。

### HTTP 1.1 （目前普遍使用）
- 默认支持持久连接
- 增加了 `pipeline` ，允许并行处理请求
- 增加了 `host` 请求头字段，通过对 `host` 解析，就能够允许在同一台物理服务器上运行多个软件服务，极大提高了服务器的使用率。目前的 `nginx` 反向代理就是根据 `HTTP` 请求头中的 `host` 来分辨不同的请求，从而将这些请求代理到同一台服务器不同的软件服务上。
> HTTP是基于 `TCP/IP` 协议的，创建一个 `TCP` 连接是需要经过三次握手，有比较大的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发送多个请求。

### HTTP 2.0
- 使用二进制的数据传输方式来替代 `HTTP 1` 中的字符串数据传输方式。
- 所有数据以“帧”的方式进行传输，因此同一个连接中发送的多个请求不再需要按照顺序进行返回处理，可以达到并发的数据传输。
- 压缩头信息进行传输数据量的优化。
- 新增了推送的概念，服务端可以主动发起一些数据推送。比如，服务端在接收到浏览器发来的 `HTML` 请求的同时，可以主动推送相关的资源文件（js/css）给客户端，并行发送，提高网页的传输和渲染效率。
> HTTP 2 的升级，主要是为了解决 HTTP 1 中存在的性能瓶颈而做的一些调整和优化。

### HTTPS
`HTTPS` 是一个安全版的 `HTTP 1.1` 。

## TCP/IP 协议族
作为 `HTTP` 的依附基础，我们有必要了解一下 `TCP/IP`。
> TCP/IP协议（传输控制协议/互联网协议）不是简单的一个协议，而是一组特别的协议，包括：TCP，IP，UDP，ARP等，这些被称为子协议。在这些协议中，最重要、最著名的就是TCP和IP。因此，大部分网络管理员称整个协议族为“TCP/IP”。

- **TCP 协议**
    - `TCP` 协议是面向连接的全双工协议，因此不管是客户端还是服务端都能在 `TCP` 连接通道下向对端接收和发送数据。
    - `TCP` 相比于 `UDP` 的优势在于它的传输稳定性，在数据传输之前必须经过三次握手建立连接；在数据传输过程中必须保证数据有序完整地传到对端。
    - `TCP` 相比于 `UDP` 的劣势在于它的复杂度，连接建立、断开都是比较大的性能开销，数据传输过程中一旦卡住，则必须等前面的数据发送完毕以后，后续数据才能继续传输。
    - 每台服务器可提供支持的 `TCP` 连接数量是有限的。
- **UDP 协议**
    - `UDP` 协议是面向无连接的，不需要在传输数据前先建立连接。
    - `UDP` 做的工作只是报文搬运，不负责有序且不丢失地传递到对端，因此容易出现丢包的情况。
    - `UDP` 不仅支持一对一的传输方式，还支持一对多、多对多、多对一的方式，也就是说 `UPD` 提供了单播、多播、广播的功能。
    - `UDP` 相比于 `TCP` 的优势在于它的轻量、高效和灵活，在一些对于实时性应用要求较高的场景下需要使用到 `UDP`，比如直播、视频会议、LOL等实时对战游戏。
    - `UDP` 相比于 `TCP` 的劣势在于它的不可靠性和不稳定性。
    
## TCP 的三次握手和四次挥手
### 三次握手
在客户端和服务端互相发送接受数据之前，即在正式发送 `HTTP` 请求之前，需要先创建一个 `TCP` 连接，在创建的 `TCP Connect`  通道下，`HTTP` 请求和响应才能正常的发送和接受，`HTTP` 只负责传输数据包，并没有连接的概念，因此 `HTTP` 也被叫做“无状态协议”。
在不同的 `HTTP` 协议版本里，这个 `TCP` 连接通道的创建机制也有所不同。
- 在 `HTTP1.0` 中，每一次 `HTTP` 请求都会创建一个 `TCP` 连接，在请求发送完成，服务器响应以后，这个 `TCP` 连接就自动断开了。
- 在 `HTTP1.1` 中，可以通过设置 `Header` 中的 `Keep-Alive` 来建立 `TCP` 的持久连接，多个 `HTTP` 请求可以共用一个 `TCP` 连接。
- 在 `HTTP2` 中，`TCP` 连接支持并发请求。

![TCP 的三次握手](https://github.com/CRONWMMM/IT-output/blob/master/images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg)

> 关于 `ACK`、`FIN`、`SYN` 状态码的含义：
> 1. `ACK` 用于确认，表示通知对方，我已经收到你发来的信息了。
> 2. `FIN` 用于结束，表示告知对方，我这边已经结束，数据全部发送完毕，没有后续输出，请求终止连接。
> 3. `SYN` 用于同步和发送当前状态，表示向对方发送一些正式的数据包/通信信息等。

1. 第一次握手：由客户端向服务端发送连接请求报文段，该报文段中包含自身的数据通讯初始序号，请求发送后，客户端便进入 `SYN-SENT` 状态。
2. 第二次握手：服务端收到连接请求报文段后，如果同意连接，**则会发送一个应答，该应答中也会包含自身的数据通讯初始序号**（在断开连接的“四次挥手”时，这两个消息是独立开来发送的，因此会有四次挥手），发送完成后便进入 `SYN-RECEIVED` 状态。
3. 第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 `ESTABLISHED` 状态，服务端收到这个应答后也进入 `ESTABLISHED` 状态，此时连接建立成功。

> 面试时可能会问的一个问题就是，明明两次握手就能确定的连接，为什么需要三次握手？
> 因为由于很多不可控制的因素，例如网络原因，可能会造成第一次请求隔了很久才到达服务端，这个时候客户端已经等待响应等了很久，之前发起的请求已超时，已经被客户端废弃掉不再继续守着监听了。
> 然而服务端过了很久，收到了废弃的延迟请求，发起回应的同时又开启了一个新的 `TCP` 连接端口，在那里呆等客户端。
> 而服务端能维护的 `TCP` 连接是有限的，这种闲置的无用链接会造成服务端的资源浪费。
> 因此在服务端发送了 `SYN` 和 `ACK` 响应后，需要收到客户端接的再次确认，双方连接才能正式建立起来。三次握手就是为了规避这种由于网络延迟而导致服务器额外开销的问题。

### 四次挥手

![TCP 的四次挥手](https://github.com/CRONWMMM/IT-output/blob/master/images/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg)

和建立 `TCP` 连接类似，断开 `TCP` 连接也同样需要客户端于服务端的双向交流，因为整个断开动作需要双端共发送 4 个数据包才能完成，所以简称为“四次挥手”。
1. 第一次挥手：客户端认为自己这边的数据已经全部发送完毕了，于是发送一个 `FIN` 用来关闭客户端到服务端的数据传输，发送完成以后，客户端进入 `FIN_WAIT_1` 状态。
2. 第二次挥手：服务端收到客户端发送回来的 `FIN` 以后，会告诉应用层要释放 TCP 链接，并且发送一个 `ACK` 给客户端，表明已经收到客户端的释放请求了，不会再接受客户端发来的数据，自此，服务端进入 `CLOSE_WAIT` 的状态。
3. 第三次挥手：服务端如果此时还有未发送完的数据可以继续发送，发送完毕后，服务端也会发送一个释放连接的 `FIN` 请求用来关闭服务端到客户端的数据传送，然后服务端进入 `LAST_ACK` 状态。
4. 第四次挥手：客户端接收到服务端的 `FIN` 请求后，发送最后一个 `ACK` 给服务端，接着进入 `TIME_WAIT_2` 状态，该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，客户端就进入 `CLOSED` 状态.服务端在收到应答消息后，也会进入 `CLOSED` 状态，至此完成四次挥手的过程，双方正式断开连接。

上面的内容可能还是有些不够直观，所以我还准备了一段人话来描述整个过程：
1. 客户端：喂，我好了。
2. 服务端：噢，你好了是吧，我知道了，我还没好，你等一哈。
3. 服务端：OK，现在我也好了。
4. 客户端：收到，这次玩的很开心，我们下次再约。

> 可能有些面试中会问，为什么建立连接有三次握手，而断开连接却有四次？
> 这是因为在建立连接过程中，服务端在收到客户但建立连接请求的 `SYN` 报文后，会把 `ACK` 和 `SYN` 放在一个报文里发送给客户端。
> 而关闭连接时，服务端收到客户端的 `FIN` 报文，只是表示客户端不再发送数据了，但是还能接收数据，而且这会儿服务端可能还有数据没有发送完，不能马上发送 `FIN` 报文，只能先发送 `ACK` 报文，先响应客户端，在确认自己这边所有数据发送完毕以后，才会发送 `FIN`。
> 所以，在断开连接时，服务器的 `ACK` 和 `FIN` 一般都会单独发送，这就导致了断开连接比请求连接多了一次发送操作。

### HTTP 报文
![HTTP报文格式](https://github.com/CRONWMMM/IT-output/blob/master/images/HTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.jpg)

`HTTP` 是以请求和响应的形式存在的，有发起方主动发起一个 `HTTP` 请求，然后由响应方回应，双方按照一定的报文格式进行数据的互传，上图是 `HTTP` 请求和响应包文的大概格式，由“首行”、“首部”和主体构成。
1. 首行，首行并不属于 `Http Headers` ，包含了：
    - `HTTP Method`（`GET`、`POST`、`PUT`、`DELETE` 等 `HTTP Method` ）
    - 

## URI、URL 和 URN
### URI 
Uniform Resource Identifier/统一资源标志符

### URL
Uniform Resource Locator/统一资源定位器

## HTTP 请求

## HTTP 缓存

## HTTP 请求头

## HTTP 响应头

## HTTP 性能优化
> 从在浏览器 url 地址栏输入回车到页面渲染完成的一张流程图，
> 每一个节点就是 HTTP 做的一件重要的事情，开发者可以根据每个节点，进行优化从而达到性能的提升。

浏览器控制台里有一个选项 `performence` ，它会为我们记录 HTTP 请求发起到页面渲染完成这段过程中的每一个过程点，在 HTTP 请求和浏览器渲染的过程中存在着时间的消耗，这个 `performence`，可以为我们记录每个时间点上所消耗的时间。
对于开发者来说，我们通过 `performence` 记录的过程节点，就可以清楚地看到哪个过程耗时比较长，就可以有针对地进行优化。

## CORS 实现跨域

## HTTPS

## HTTPS 的创建过程

## 为什么 HTTPS 是相对安全的

## 什么是长链接，为什么需要长链接

## HTTPS 的信道复用及性能优化
